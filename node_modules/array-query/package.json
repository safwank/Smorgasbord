{
  "name": "array-query",
  "description": "Provides an interface to pull objects out of a JavaScript array with minimal code. Useful for Backbone collections and similar scenarios.",
  "author": {
    "name": "Jacob Wright",
    "email": "jacwright@gmail.com"
  },
  "keywords": [
    "array",
    "database",
    "query",
    "select",
    "where"
  ],
  "version": "0.1.0",
  "main": "lib/query",
  "maintainers": [
    {
      "name": "Jacob Wright",
      "email": "jacwright@gmail.com",
      "url": "http://jacwright.com"
    }
  ],
  "contributors": [
    {
      "name": "Jacob Wright",
      "email": "jacwright@gmail.com",
      "url": "http://jacwright.com"
    }
  ],
  "homepage": "https://github.com/jacwright/array-query",
  "repository": {
    "type": "git",
    "url": "git://github.com/jacwright/array-query.git"
  },
  "readme": "query\n=====\n\nProvides an interface to pull objects out of a JavaScript array with minimal code. Useful for Backbone collections and similar scenarios. Can be used in the browser and on the server (node.js).\n\n## Why?\n\nThough you can do everything query provides you with the built-in Array methods (forEach, map, filter, etc), query can make it much more readable and concise.\n\n## Install\n\n```\nnpm install array-query\n```\n\nNow you can use it in your node.js project.\n\n```js\nvar query = require('array-query');\n\nvar firstJacob = query('name').startsWith('Jacob').on(users).pop();\n```\n\nOr just add the query.js file to your web page for use in your client-side JavaScript.\n\n## querying\n\nFinding objects in an array with query is easy. The API takes a property name first, then checks the value, then you can continue to add properties and checks until the `on` method is called with the array you are querying.\n\nIt is probably easier to see it in action. The following will return all users with the name Bob.\n\n```js\nvar allBobs = query('firstName').is('Bob').on(users);\n```\n\n### query Chaining\n\nWhen you call `query()` it creates a new query object which returns a reference to itself. In fact, most methods of the query object return a reference to itself enabling method chaining. For example, the following three queries are all the same.\n\n```js\nvar q1 = query(\"author\");\nq1.is(\"Terence Hanbury White\");\nq1.and(\"title\");\nq1.is(\"The Once and Future King\");\n\nvar q2 = query(\"author\").is(\"Terence Hanbury White\");\nq2.and(\"title\").is(\"The Once and Future King\");\n\nvar q3 = query(\"author\").is(\"Terence Hanbury White\").and(\"title\").is(\"The Once and Future King\");\n\nif (q1.toString() == q2.toString() == q3.toString()) alert(\"They're all the same!\");\n```\n\nMore examples:\n\n```js\nvar whiteBooks = query(\"author\").is(\"Terence Hanbury White\").on(books);\n\nvar theBooks = query(\"title\").startsWith(\"The\").on(books);\n\nvar bigBooks = query(\"pages\").gt(500).on(books);\n\nvar topTenBiggestBooks = query().sort(\"pages\").numeric().desc().limit(10).on(books);\n```\n\n### Select\n\nIf you'd rather start with the Array you may use the slightly different select().\n\n```js\nvar aBooks = select(books).where(\"title\").startsWith(\"A\").end();\n```\n\nThe two differences between `query` and `select` is that:\n\n  1. `query` ends with the array (e.g. `.on(books)`) and `select` starts with it (e.g. `select(books)`)\n  2. `select` needs to know when to be done chaining and to return the results, so it ends with `end()`\n\n## Basics\n\n### query\n\n`query` is the start of our query and may optionally take the first field we want to filter by. The `query` method does not need to take a field if you only want to sort or limit the objects.\n\n```js\nquery().sort(\"lastName\").limit(20).on(users);\n\nquery(\"age\").gt(20).on(users);\n```\n\nThe first query listed here shows using `query()` without a parameter. It sorts by lastName and limits the results to 20 objects. The second query gets all the objects where age is greater than 20. \n\n### and, or\n\nquery provides the ability to use `and()` and `or()` in putting together your query. These usually take a parameter, which can either be a field name or another query object. The field name is only the beginning of an expression and when used should be followed up with another method call such as `equals()`, `gt()`, etc.\n\n```js\nquery(\"username\").equals(\"test\").or(\"password\").equals(\"test\").on(users);\n```\n\nThis looks up all objects whose username or password is \"test\".\n\nQuery objects may be used inside the methods `and()` and `or()` to provide subqueries. This is like putting parenthesis around the expression.\n\n```js\nvar notMiddleAged = query(\"firstName\").equals(\"John\").and(query(\"age\").lt(20).or(\"age\").gt(60)));\n```\n\nThis query allows us to find all objects where the `firstName` is John and the age is either less than 20 or more than 60. We are unable to do this kind of sub-querying with the object-based API.\n\n## not\n\nThe `not()` method can be used in an expression to negate the results.\n\n```js\nquery(\"age\").not().gt(20).and(\"eyeColor\").not().equals(\"blue\").on(users);\n```\n\nThis query will get every object where age is not more than 20 and eye color is not blue.\n\n## Operations\n\n\n### is, equals\n\n`equals` is the most basic. The query should just be the value you want to match.\n\n```js\nquery(\"firstName\").is(\"John\").on(users);\n\nquery(\"lastName\").equals(\"Smith\").on(users);\n```\n\nThis will match all objects where property `firstName` equals \"John\". `is` and `equals` are synonymous.\n\n### within\n\n`within` tests whether the object's value is within a provided array of values.\n\n```js\nquery(\"firstName\").within([ \"John\", \"Jacob\", \"Jingle\", \"Heimer\" ]).on(users);\n```\n\nThis will match all objects whose firstName is \"John\", \"Jacob\", \"Jingle\", or \"Heimer\".\n\n### has\n\n`has` matches objects which have the provided value in an array.\n\n```js\ndb.add({ colors: [ \"red\", \"yellow\", \"blue\" ] });\n\nquery(\"colors\").has(\"red\").on(users);\n```\n\nThis will match the previously added object since it's colors array *has* the value \"red\". Note that if on the stored objects, colors is null or an empty array, it will not match since it doesn't have \"red\" in the colors array.\n\n### hasAll\n\n`hasAll` matches objects which have all the provided values in an array.\n\n```js\nquery(\"colors\").hasAll([\"red, \"blue\"]).on(users);\n```\n\nThis will match all objects which have both \"red\" and \"blue\" in their colors array.\n\n### startsWith\n\n`startsWith` matches the beginning of a value.\n\n```js\nquery(\"firstName\").startsWith(\"J\").on(users);\n```\n\nThis will match all objects whose `firstName` begins with \"J\".\n\n### endsWith\n\n`endsWith` matches the end of a value.\n\n```js\nquery(\"lastName\").endsWith(\"son\").on(users);\n```\n\nThis will match all objects whose `lastName` ends with \"son\".\n\n### gt\n\n`gt` matches objects whose value is greater than what's provided. Dates are supported.\n\n```js\nquery(\"age\").gt(20).on(users);\n```\n\nThis will match objects with `age` greater than 20;\n\n### gte\n\n`gte` matches objects whose value is greater than or equal to what's provided. Dates are supported.\n\n```js\nquery(\"age\").gte(20).on(users);\n```\n\nThis will match objects with `age` greater than or equal to 20;\n\n### lt\n\n`lt` matches objects whose value is less than what's provided. Dates are supported.\n\n```js\nquery(\"age\").lt(20).on(users);\n```\n\nThis will match objects with `age` less than 20;\n\n### lte\n\n`lte` matches objects whose value is less than or equal to what's provided. Dates are supported.\n\n```js\nquery(\"age\").lte(20).on(users);\n```\n\nThis will match objects with `age` less than or equal to 20;\n\n### regex\n\n`regex` matches objects whose values match the provided regular expression.\n\n```js\nquery(\"name\").regex(/[^\\w\\s]/).on(users);\n```\n\nThis will match objects that have a non word-or-space character in the `name` property.\n\n### same\n\n`same` matches objects where the value is the same when serialized into JSON. This allows arrays or objects to be matched without a reference to the original.\n\n```js\nusers.push({ name: { first: \"John\", last: \"Smith\" }, age: 30 });\n\nquery(\"name\").same({ first: \"John\", last: \"Smith\" }).on(users);\n```\n\nThis will match the added object since the `name` value is the same even if it isn't the exact instance in memory. Note that this uses the serialized JSON representation of both objects to compare. Dates should work with this method but hasn't been tested cross-browser.\n\n### type\n\n`type` matches objects where the object or property is of a given type. Valid types are a string of: object, array, number, boolean, null, undefined. Or an instance of a class (e.g. Date). If no property name is passed into the `query()`, `and()`, or `or()` methods then the type will match against the object itself rather than a property.\n\n```js\nquery(\"age\").type(\"number\").on(users);\n\nquery(\"published\").type(Date).on(users);\n\nquery(\"pet\").type(Dog).on(users);\n\nquery().type(User).or().type(Person).on(users); // matches if the object is and instance of User or Person (or a subclass thereof)\n```\n\nThe first call will match all objects with a number for the age. The second call will match all objects where published is an instance of Date. The third call will match all `User` and `Person` objects in the database.\n\n### filter\n\n`filter` allows a custom filter function to be run against the value of a property or the object as a whole. If the function returns true, the object is added to the query results.\n\n```js\nquery(\"firstName\").filter(function(name) {\n    return name.toLowerCase().charAt(0) === \"a\";\n}).on(users);\n\nquery().filter(function(obj) {\n    if (obj instanceof User) {\n        return obj.active;\n    } else if (obj instanceof Person) {\n        return obj.trustLevel === \"trusted\";\n    } else {\n        return false;\n    }\n}).on(users);\n```\n\nThe first query here uses a custom function to match against the value of the `firstName` property of every object. The second query uses a custom function to use custom logic to match against every object because no property name was passed into the `query()` function.\n\n### search\n\n`search` matches all objects with a full-text search on the given field.\n\n```js\nquery('bio').search(\"looking for all of these words\").on(users);\n```\n\nThis will match any objects which have the provided words in their `bio` field.\n\n### sort\n\nSorts the returned results by property. Additional sort methods may follow a sort to define it further: `asc()`, `desc()`, `regular()`, `numeric()`, `date()`, and `custom()`. The default sort uses `asc()` and `regular()`, so these don't need to be used explicitly. Custom allows sorting on a property or on the object as a whole.\n\n```js\nquery(\"active\").is(true).sort(\"lastName\").on(users);\n\nquery().sort(\"lastName\").desc().on(users);\n\nquery().sort(\"publishedDate\").date().desc().sort(\"title\").on(users);\n\nquery().sort(\"age\").custom(function(age1, age2) {\n    if (age1 < age2) return -1;\n    else if (age1 > age2) return 1;\n    else return 0;\n}).on(users);\n\nquery().sort().custom(function(obj1, obj2) {\n    return obj1.age - obj2.age;\n}).on(users);\n```\n\nThe first query sorts by `lastName` after selecting only active objects. The second query sorts all objects by `lastName` in descending or reverse order. The third query sorts by `publishDate` with most recent first, then by title for dates that are the same. The fourth query uses a custom sort on the age property. The last query uses a custom sort on the object as a whole.\n\n### limit\n\nLimit the results returned.\n\n```js\nquery().limit(10).on(users);\n```\n\nThis returns 10 objects from the top of the array.\n\n```js\nquery().sort('noisy').limit(10).on(users);\n```\n\nThis returns 10 noisiest users (whatever that might mean).\n\n### offset\n\nWorks with limit to select an offset which to start your limit at. This is used mostly for pagination.\n\n```js\nquery().limit(10).offset(100).on(users);\n```\n\nThis returns 10 objects starting at the 100th object.\n\n\n### Complex properties/fields\n\nQuery fields can be dot-delimited to match sub-properties. They may even use methods. Note that the query object does not check to ensure whether the property is null, so if it is on some objects but not others you'll want to check for that first.\n\n```js\nusers.push({ name: \"Bob\", colors: [ \"red\", \"yellow\", \"blue\" ] });\n\nquery(\"colors.length\").is(3).on(users);\nquery(\"colors.length\").gt(2).on(users);\nquery(\"colors.length\").lte(3).on(users);\n```\n\nThese will *all* match the added object because the length is equal to three, greater than two, and less than or equal to three.\n\n```js\nusers.push({ colors: [ \"red\", \"yellow\", \"blue\" ] });\nusers.push({ colors: null });\n\nquery(\"colors.length\").is(0).on(users); // will not match the newly added object because it is null\n\nquery(\"colors\").is(null).or(\"colors.length\").is(0).on(users); // this is how you should check\n```\n\nTo check for a name without respect to case you might do the following.\n\n```js\nquery('firstName.toLowerCase()').is('bob');\n\nquery().sort('lastName.toLowerCase()');\n```\n\nThe second query above will sort by last name irrespective of casing.\n\n## Backbone Support and Adding query to Backbone.Collections\n\nquery was built with Backbone in mind. Though you may use `query(\"get('firstName')\").is(\"John\")` to effectively work with\nBackbone models, query allows you to shorten that to just use `firstName` as in `query(\"firstName\").is(\"John\")`. You can\neven add methods like the previous section indicates like: `query(\"firstName.toLowerCase()\").is(\"john\")`.\n\nYou may find it useful to add query to the Collection interface so that it is avaiable with every collection.\n\n```js\nvar Backbone = require('backbone');\nvar query = require('array-query'); // these lines may be skipped when using in the browser\n\nBackbone.Collection.prototype.query = function(field) {\n    return query.select(@models).where(field);\n}\n\n// then when using it remember to use `end()` as this is the `select()` style API.\nvar activeUsers = userCollection.query('active').is(true).end();\n\n```\n\nOne addition which was added specifically for Backbone (though could be altered to work elsewhere if needed) was the `set()` method.\nUsing it you may set properties on all the matching objects.\n\n```js\nuserCollection.query('selected').is(true).set({ selected: false }).end();\n```\n\nThis will set all currently selected users to not selected. And because this is Backbone, any Views listening to the\n`change:selected` event can update accordingly.\n",
  "_id": "array-query@0.1.0",
  "dist": {
    "shasum": "dd4e1714de77fa1a4353ad739c8176161edd6c40"
  },
  "_from": "array-query"
}
