(function() {
  var URL, flatten, request, unflatten,
    __slice = [].slice;

  request = require('request');

  URL = require('url');

  exports.wrapRequestForAuth = function(url) {
    var auth, fixArgs, verb, wrapper, _fn, _i, _len, _ref;
    auth = URL.parse(url).auth;
    if (!auth) {
      return request;
    }
    fixArgs = function(args) {
      if (typeof args[0] === 'string') {
        url = args[0];
      } else {
        url = args[0].url || args[0].uri;
      }
      if (!url) {
        console.log('UH OH:');
        console.log(args);
      }
      url = URL.parse(url);
      if (!url.auth) {
        url.host = "" + auth + "@" + url.host;
      }
      url = URL.format(url);
      if (typeof args[0] === 'string') {
        args[0] = url;
      } else {
        args[0].url = args[0].uri = url;
      }
      return args;
    };
    wrapper = {};
    _ref = ['get', 'post', 'put', 'del', 'head'];
    _fn = function(verb) {
      return wrapper[verb] = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return request[verb].apply(request, fixArgs(args));
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      verb = _ref[_i];
      _fn(verb);
    }
    return wrapper;
  };

  exports.adjustError = function(error) {
    var serverError;
    if (error.statusCode) {
      serverError = error.body || {
        message: 'Unknown Neo4j error.'
      };
      if (typeof serverError === 'string') {
        try {
          serverError = JSON.parse(serverError);
        } catch (_error) {}
      }
      error = new Error;
      error.message = serverError.message || serverError;
    }
    if (typeof error !== 'object') {
      error = new Error(error);
    }
    if (error.code === 'ECONNREFUSED') {
      error.message = "Couldnâ€™t reach database (connection refused)";
    }
    return error;
  };

  exports.serialize = function(o, separator) {
    return JSON.stringify(flatten(o, separator));
  };

  exports.deserialize = function(o, separator) {
    return unflatten(JSON.parse(o), separator);
  };

  flatten = function(o, separator, result, prefix) {
    var key, value, _i, _len, _ref;
    separator = separator || '.';
    result = result || {};
    prefix = prefix || '';
    if (typeof o !== 'object') {
      return o;
    }
    _ref = Object.keys(o);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      value = o[key];
      if (typeof value !== 'object') {
        result[prefix + key] = value;
      } else {
        flatten(value, separator, result, key + separator);
      }
    }
    return result;
  };

  unflatten = function(o, separator, result) {
    var currentKey, i, key, keys, lastKey, numKeys, separatorIndex, target, value, _i, _j, _len, _ref, _ref1;
    separator = separator || '.';
    result = result || {};
    if (typeof o !== 'object') {
      return o;
    }
    _ref = Object.keys(o);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      value = o[key];
      separatorIndex = key.indexOf(separator);
      if (separatorIndex === -1) {
        result[key] = value;
      } else {
        keys = key.split(separator);
        target = result;
        numKeys = keys.length;
        for (i = _j = 0, _ref1 = numKeys - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          currentKey = keys[i];
          if (target[currentKey] === void 0) {
            target[currentKey] = {};
          }
          target = target[currentKey];
        }
        lastKey = keys[numKeys - 1];
        target[lastKey] = value;
      }
    }
    return result;
  };

}).call(this);
